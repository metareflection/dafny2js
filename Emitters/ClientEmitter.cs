namespace Dafny2Js.Emitters;

/// <summary>
/// Generates JavaScript/TypeScript client adapter (app.js or app.ts) for React/Vite.
/// </summary>
public class ClientEmitter : SharedEmitter
{
  readonly bool _useTypeScript;

  public ClientEmitter(
    List<DatatypeInfo> datatypes,
    List<FunctionInfo> functions,
    string domainModule,
    string appCoreModule,
    string cjsFileName,
    bool nullOptions = false,
    bool useTypeScript = false)
    : base(datatypes, functions, domainModule, appCoreModule, cjsFileName, nullOptions)
  {
    _useTypeScript = useTypeScript;
  }

  protected override bool EmitTypeScript => _useTypeScript;

  public override string Generate()
  {
    Sb.Clear();
    TypeMapper.EmitTypeScript = EmitTypeScript;

    var allTypesToGenerate = GetAllTypesToGenerate();
    var allModules = allTypesToGenerate
      .Select(dt => dt.ModuleName)
      .Append(DomainModule)
      .Append(AppCoreModule)
      .Distinct()
      .ToList();

    // 1. Boilerplate
    EmitBoilerplate(allModules);
    Sb.AppendLine();

    // 2. Helpers
    EmitHelpers();
    Sb.AppendLine();

    // 3. TypeScript interfaces (if enabled)
    EmitTypeScriptInterfaces(allTypesToGenerate);

    // 4. Datatype conversions (must come before null-option preprocessing)
    EmitDatatypeConversions(allTypesToGenerate);

    // 5. Null-option preprocessing (wraps the converters, so must come after)
    if (NullOptions)
    {
      EmitNullOptionPreprocessing();
      Sb.AppendLine();
    }

    // 6. API wrapper
    EmitApiWrapper();

    // 7. Export internals
    Sb.AppendLine("// Export internals for custom extensions");
    var internalModules = string.Join(", ", allModules);
    Sb.AppendLine($"App._internal = {{ _dafny, {internalModules} }};");
    Sb.AppendLine();

    // 8. Export
    Sb.AppendLine("export default App;");

    return Sb.ToString();
  }

  void EmitBoilerplate(List<string> moduleNames)
  {
    var modules = string.Join(", ", moduleNames);

    Sb.AppendLine("// Generated by dafny2js");
    Sb.AppendLine("// Do not edit manually - regenerate from Dafny sources");
    Sb.AppendLine();
    Sb.AppendLine("import BigNumber from 'bignumber.js';");
    Sb.AppendLine();
    Sb.AppendLine("// Configure BigNumber as Dafny expects");
    Sb.AppendLine("BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });");
    Sb.AppendLine();
    Sb.AppendLine($"// Import the generated code as raw text");
    Sb.AppendLine($"import dafnyCode from './{CjsFileName}?raw';");
    Sb.AppendLine();
    Sb.AppendLine("// Set up the environment and evaluate the Dafny code");

    if (EmitTypeScript)
    {
      Sb.AppendLine("const require = (mod: string) => {");
    }
    else
    {
      Sb.AppendLine("const require = (mod) => {");
    }
    Sb.AppendLine("  if (mod === 'bignumber.js') return BigNumber;");
    Sb.AppendLine("  throw new Error(`Unknown module: ${mod}`);");
    Sb.AppendLine("};");
    Sb.AppendLine();
    Sb.AppendLine("// Create a function that evaluates the code with proper scope");
    Sb.AppendLine("const initDafny = new Function('require', `");
    Sb.AppendLine("  ${dafnyCode}");
    Sb.AppendLine($"  return {{ _dafny, {modules} }};");
    Sb.AppendLine("`);");
    Sb.AppendLine();
    Sb.AppendLine($"const {{ _dafny, {modules} }} = initDafny(require);");
  }

  void EmitNullOptionPreprocessing()
  {
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine("// Null-Option Preprocessing (for DB compatibility)");
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine();
    Sb.AppendLine("// Convert null to { type: 'None' } for Option fields");

    if (EmitTypeScript)
    {
      Sb.AppendLine("// deno-lint-ignore no-explicit-any");
      Sb.AppendLine("const fixOption = (val: any): any => {");
    }
    else
    {
      Sb.AppendLine("const fixOption = (val) => {");
    }
    Sb.AppendLine("  if (val === null || val === undefined) return { type: 'None' };");
    Sb.AppendLine("  if (val && val.type) return val; // Already in correct format");
    Sb.AppendLine("  return { type: 'Some', value: val };");
    Sb.AppendLine("};");
    Sb.AppendLine();

    // Generate preprocessor for each type that has Option fields
    var typesWithOptions = GetTypesWithOptionFields();
    foreach (var dt in typesWithOptions)
    {
      EmitTypePreprocessor(dt);
    }
  }

  List<DatatypeInfo> GetTypesWithOptionFields()
  {
    var result = new List<DatatypeInfo>();
    var allTypes = GetAllTypesToGenerate();

    foreach (var dt in allTypes)
    {
      foreach (var ctor in dt.Constructors)
      {
        if (ctor.Fields.Any(f => f.Type.Name == "Option"))
        {
          result.Add(dt);
          break;
        }
      }
    }

    return result;
  }

  void EmitTypePreprocessor(DatatypeInfo dt)
  {
    var funcName = $"preprocess{dt.Name}Json";
    var lower = dt.Name.ToLowerInvariant();

    if (EmitTypeScript)
    {
      Sb.AppendLine("// deno-lint-ignore no-explicit-any");
      Sb.AppendLine($"const {funcName} = (json: any): any => {{");
    }
    else
    {
      Sb.AppendLine($"const {funcName} = (json) => {{");
    }
    Sb.AppendLine("  if (!json) return json;");

    // Single constructor case
    if (dt.Constructors.Count == 1)
    {
      var ctor = dt.Constructors[0];
      var optionFields = ctor.Fields.Where(f => f.Type.Name == "Option").ToList();

      if (optionFields.Count > 0)
      {
        Sb.AppendLine("  return {");
        Sb.AppendLine("    ...json,");
        foreach (var field in optionFields)
        {
          Sb.AppendLine($"    {field.Name}: fixOption(json.{field.Name}),");
        }
        Sb.AppendLine("  };");
      }
      else
      {
        Sb.AppendLine("  return json;");
      }
    }
    else
    {
      // Multi-constructor: check each constructor and fix its Option fields
      Sb.AppendLine("  switch (json.type) {");
      foreach (var ctor in dt.Constructors)
      {
        var optionFields = ctor.Fields.Where(f => f.Type.Name == "Option").ToList();
        if (optionFields.Count > 0)
        {
          Sb.AppendLine($"    case '{ctor.Name}':");
          Sb.AppendLine("      return {");
          Sb.AppendLine("        ...json,");
          foreach (var field in optionFields)
          {
            Sb.AppendLine($"        {field.Name}: fixOption(json.{field.Name}),");
          }
          Sb.AppendLine("      };");
        }
      }
      Sb.AppendLine("    default:");
      Sb.AppendLine("      return json;");
      Sb.AppendLine("  }");
    }

    Sb.AppendLine("};");
    Sb.AppendLine();

    // Create wrapped version that uses preprocessing
    Sb.AppendLine($"// Wrapped {lower}FromJson with preprocessing");
    Sb.AppendLine($"const _{lower}FromJsonOriginal = {lower}FromJson;");

    if (EmitTypeScript)
    {
      Sb.AppendLine("// deno-lint-ignore no-explicit-any");
      Sb.AppendLine($"const {lower}FromJsonPreprocessed = (json: any): any => _{lower}FromJsonOriginal({funcName}(json));");
    }
    else
    {
      Sb.AppendLine($"const {lower}FromJsonPreprocessed = (json) => _{lower}FromJsonOriginal({funcName}(json));");
    }
    Sb.AppendLine();

    // Track this type for export override
    _typesWithPreprocessing.Add(lower);
  }

  // Track types that have preprocessing wrappers
  readonly HashSet<string> _typesWithPreprocessing = new();

  /// <summary>
  /// Override to export preprocessed versions when null-options is enabled.
  /// </summary>
  protected new void EmitApiWrapper()
  {
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine("// API Wrapper");
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine();
    Sb.AppendLine("const App = {");

    // Generate constructors for helper datatypes
    var helperTypes = Datatypes
      .Where(dt => dt.ModuleName == DomainModule &&
                   dt.Name != "Model" &&
                   dt.Name != "Action")
      .ToList();

    foreach (var helperType in helperTypes)
    {
      Sb.AppendLine($"  // {helperType.Name} constructors");
      foreach (var ctor in helperType.Constructors)
      {
        EmitDatatypeConstructor(helperType.Name, ctor);
      }
      Sb.AppendLine();
    }

    // Action constructors
    var actionType = Datatypes.FirstOrDefault(dt =>
      dt.ModuleName == DomainModule && dt.Name == "Action");

    if (actionType != null)
    {
      Sb.AppendLine("  // Action constructors");
      foreach (var ctor in actionType.Constructors)
      {
        EmitActionConstructor(ctor);
      }
      Sb.AppendLine();
    }

    // Model accessors
    var modelType = Datatypes.FirstOrDefault(dt =>
      dt.ModuleName == DomainModule && dt.Name == "Model");

    if (modelType != null && modelType.Constructors.Count > 0)
    {
      Sb.AppendLine("  // Model accessors");
      EmitModelAccessors(modelType);
      Sb.AppendLine();
    }

    // AppCore functions
    if (Functions.Count > 0)
    {
      var actionCtorNames = actionType?.Constructors.Select(c => c.Name).ToHashSet() ?? new HashSet<string>();
      var modelAccessorNames = modelType?.Constructors.FirstOrDefault()?.Fields
        .Select(f => "Get" + char.ToUpper(f.Name[0]) + f.Name.Substring(1))
        .ToHashSet() ?? new HashSet<string>();

      var filteredFuncs = Functions
        .Where(f => !actionCtorNames.Contains(f.Name))
        .Where(f => !modelAccessorNames.Contains(f.Name))
        .ToList();

      if (filteredFuncs.Count > 0)
      {
        Sb.AppendLine("  // AppCore functions");
        foreach (var func in filteredFuncs)
        {
          EmitFunctionWrapper(func);
        }
        Sb.AppendLine();
      }
    }

    // Conversion functions - export preprocessed versions when available
    Sb.AppendLine("  // Conversion functions");
    var allTypesToGenerate = GetAllTypesToGenerate();
    var exportedNames = new HashSet<string>();

    foreach (var dt in allTypesToGenerate)
    {
      var lower = TypeMapper.SanitizeForJs(dt.Name).ToLowerInvariant();
      if (!exportedNames.Add(lower)) continue;
      Sb.AppendLine($"  {lower}ToJson: {lower}ToJson,");
      // Export preprocessed version if available, otherwise original
      if (_typesWithPreprocessing.Contains(lower))
      {
        Sb.AppendLine($"  {lower}FromJson: {lower}FromJsonPreprocessed,");
      }
      else
      {
        Sb.AppendLine($"  {lower}FromJson: {lower}FromJson,");
      }
    }

    Sb.AppendLine("};");
    Sb.AppendLine();
  }
}
