namespace Dafny2Js.Emitters;

/// <summary>
/// Configuration for a dispatch function to generate.
/// </summary>
public record DispatchConfig(
  string Name,                    // e.g., "dispatch" or "multiDispatch"
  string DispatchFunctionPath,    // e.g., "TodoMultiCollaboration.Dispatch"
  string CollaborationModule,     // e.g., "TodoMultiCollaboration"
  string? CjsFilePath = null      // Optional: path to a different .cjs file for this dispatch
);

/// <summary>
/// Generates TypeScript Deno adapter (dafny-bundle.ts) for Supabase Edge Functions.
/// </summary>
public class DenoEmitter : SharedEmitter
{
  readonly string _cjsFilePath;
  readonly List<DispatchConfig> _dispatches;

  public DenoEmitter(
    List<DatatypeInfo> datatypes,
    List<FunctionInfo> functions,
    string domainModule,
    string appCoreModule,
    string cjsFileName,
    string cjsFilePath,
    List<DispatchConfig> dispatches,
    bool nullOptions = false)
    : base(datatypes, functions, domainModule, appCoreModule, cjsFileName, nullOptions)
  {
    _cjsFilePath = cjsFilePath;
    _dispatches = dispatches;
  }

  protected override bool EmitTypeScript => true;

  public override string Generate()
  {
    Sb.Clear();
    TypeMapper.EmitTypeScript = EmitTypeScript;

    var allTypesToGenerate = GetAllTypesToGenerate();

    // Collect all modules needed (including collaboration modules from dispatches)
    var allModules = allTypesToGenerate
      .Select(dt => dt.ModuleName)
      .Append(DomainModule)
      .Append(AppCoreModule)
      .Concat(_dispatches.Select(d => d.CollaborationModule))
      .Distinct()
      .ToList();

    // 1. Header and imports
    EmitHeader();
    Sb.AppendLine();

    // 2. Dafny runtime setup
    EmitDafnyRuntimeSetup(allModules);
    Sb.AppendLine();

    // 3. Helpers
    EmitHelpers();
    Sb.AppendLine();

    // 4. Null-option preprocessing (if enabled)
    if (NullOptions)
    {
      EmitNullOptionPreprocessing();
      Sb.AppendLine();
    }

    // 5. Datatype conversions
    EmitDatatypeConversions(allTypesToGenerate);

    // 6. Export converters and modules
    EmitExports(allModules, allTypesToGenerate);
    Sb.AppendLine();

    // 7. ServerState conversions (if we have dispatches)
    if (_dispatches.Count > 0)
    {
      EmitServerStateConversions(_dispatches[0].CollaborationModule);
    }

    // 8. Dispatch functions
    foreach (var dispatch in _dispatches)
    {
      EmitDispatchFunction(dispatch);
      Sb.AppendLine();
    }

    return Sb.ToString();
  }

  void EmitHeader()
  {
    Sb.AppendLine("// Generated by dafny2js");
    Sb.AppendLine("// DO NOT EDIT - regenerate with: ./compile.sh");
    Sb.AppendLine();
    Sb.AppendLine("import BigNumber from 'https://esm.sh/bignumber.js@9.1.2';");
    Sb.AppendLine();
    Sb.AppendLine("BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });");
  }

  void EmitDafnyRuntimeSetup(List<string> moduleNames)
  {
    // Read and escape the .cjs file
    var dafnyCode = File.ReadAllText(_cjsFilePath);
    var escapedCode = EscapeForTemplateLiteral(dafnyCode);

    var modules = string.Join(", ", moduleNames);

    Sb.AppendLine();
    Sb.AppendLine("// Dafny runtime mock for require");
    Sb.AppendLine("const require = (mod: string) => {");
    Sb.AppendLine("  if (mod === 'bignumber.js') return BigNumber;");
    Sb.AppendLine("  throw new Error(`Unknown module: ${mod}`);");
    Sb.AppendLine("};");
    Sb.AppendLine();
    Sb.AppendLine("// deno-lint-ignore no-unused-vars");
    Sb.AppendLine("const exports = {};");
    Sb.AppendLine("// deno-lint-ignore no-unused-vars");
    Sb.AppendLine("const module = { exports };");
    Sb.AppendLine();
    Sb.AppendLine("// Evaluate Dafny code");
    Sb.AppendLine("const initDafny = new Function('require', 'exports', 'module', `");
    Sb.AppendLine(escapedCode);
    Sb.AppendLine($"  return {{ _dafny, {modules} }};");
    Sb.AppendLine("`);");
    Sb.AppendLine();
    Sb.AppendLine($"const {{ _dafny, {modules} }} = initDafny(require, exports, module);");
  }

  string EscapeForTemplateLiteral(string code)
  {
    // Escape backticks, backslashes, and $ for template literal
    return code
      .Replace("\\", "\\\\")
      .Replace("`", "\\`")
      .Replace("$", "\\$");
  }

  void EmitNullOptionPreprocessing()
  {
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine("// Null-Option Preprocessing (for DB compatibility)");
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine();
    Sb.AppendLine("// Convert null to { type: 'None' } for Option fields");
    Sb.AppendLine("// deno-lint-ignore no-explicit-any");
    Sb.AppendLine("const fixOption = (val: any): any => {");
    Sb.AppendLine("  if (val === null || val === undefined) return { type: 'None' };");
    Sb.AppendLine("  if (val && val.type) return val;");
    Sb.AppendLine("  return { type: 'Some', value: val };");
    Sb.AppendLine("};");
    Sb.AppendLine();

    // Handle tagged option format from client
    Sb.AppendLine("// Handle tagged option format from client: { type: 'Some', value: ... } or { type: 'None' }");
    Sb.AppendLine("// deno-lint-ignore no-explicit-any");
    Sb.AppendLine("const taggedOptionToValue = (val: any, converter: (x: any) => any = (x) => x): any => {");
    Sb.AppendLine("  if (val === null || val === undefined) {");
    Sb.AppendLine($"    return {DomainModule}.Option.create_None();");
    Sb.AppendLine("  }");
    Sb.AppendLine("  if (val.type === 'None') {");
    Sb.AppendLine($"    return {DomainModule}.Option.create_None();");
    Sb.AppendLine("  }");
    Sb.AppendLine("  if (val.type === 'Some') {");
    Sb.AppendLine($"    return {DomainModule}.Option.create_Some(converter(val.value));");
    Sb.AppendLine("  }");
    Sb.AppendLine("  // Fallback: treat as raw value");
    Sb.AppendLine($"  return {DomainModule}.Option.create_Some(converter(val));");
    Sb.AppendLine("};");
    Sb.AppendLine();

    // Option to JS (null-based)
    Sb.AppendLine("// Convert Dafny Option to null-based JS");
    Sb.AppendLine("// deno-lint-ignore no-explicit-any");
    Sb.AppendLine("const optionToJs = (opt: any, converter: (x: any) => any = (x) => x): any => {");
    Sb.AppendLine("  if (opt.is_None) return null;");
    Sb.AppendLine("  return converter(opt.dtor_value);");
    Sb.AppendLine("};");
    Sb.AppendLine();
  }

  void EmitExports(List<string> allModules, List<DatatypeInfo> allTypesToGenerate)
  {
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine("// Exports");
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine();

    // Export modules
    var modulesStr = string.Join(", ", allModules);
    Sb.AppendLine($"export {{ _dafny, {modulesStr}, BigNumber }};");
    Sb.AppendLine();

    // Export converters
    var exportedNames = new HashSet<string>();
    foreach (var dt in allTypesToGenerate)
    {
      var lower = TypeMapper.SanitizeForJs(dt.Name).ToLowerInvariant();
      if (!exportedNames.Add(lower)) continue;
    }

    if (exportedNames.Count > 0)
    {
      var converterExports = exportedNames
        .SelectMany(n => new[] { $"{n}FromJson", $"{n}ToJson" });
      Sb.AppendLine($"export {{ {string.Join(", ", converterExports)} }};");
    }

    Sb.AppendLine();
    Sb.AppendLine("export { dafnyStringToJs, seqToArray, toNumber };");
  }

  void EmitDispatchFunction(DispatchConfig config)
  {
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine($"// {config.Name} - Verified Dispatch Function");
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine();

    // TypeScript interfaces
    EmitDispatchInterfaces(config);

    // The dispatch function itself
    Sb.AppendLine($"export function {config.Name}(");
    Sb.AppendLine("  stateJson: any,");
    Sb.AppendLine("  appliedLog: any[],");
    Sb.AppendLine("  baseVersion: number,");
    Sb.AppendLine("  actionJson: any,");
    Sb.AppendLine("  auditLog?: any[]");
    Sb.AppendLine("): DispatchResult {");

    // Build ServerState from JSON
    Sb.AppendLine("  // Build ServerState from JSON");
    Sb.AppendLine("  const serverState = serverStateFromJson({");
    Sb.AppendLine("    present: stateJson,");
    Sb.AppendLine("    appliedLog: appliedLog,");
    Sb.AppendLine("    auditLog: auditLog || []");
    Sb.AppendLine("  });");
    Sb.AppendLine();

    // Call verified Dispatch
    Sb.AppendLine("  // Call VERIFIED Dispatch");
    Sb.AppendLine("  const action = actionFromJson(actionJson);");
    Sb.AppendLine($"  const result = {config.CollaborationModule}.__default.Dispatch(");
    Sb.AppendLine("    serverState,");
    Sb.AppendLine("    new BigNumber(baseVersion),");
    Sb.AppendLine("    action");
    Sb.AppendLine("  );");
    Sb.AppendLine();

    // Extract result (tuple: [newServerState, reply])
    Sb.AppendLine("  // Result is a tuple: [newServerState, reply]");
    Sb.AppendLine("  const newServerState = result[0];");
    Sb.AppendLine("  const reply = result[1];");
    Sb.AppendLine();

    // Convert result
    Sb.AppendLine("  // Extract new state");
    Sb.AppendLine("  const newStateJson = serverStateToJson(newServerState);");
    Sb.AppendLine();

    // Handle reply type
    Sb.AppendLine("  // Check reply type");
    Sb.AppendLine("  if (reply.is_Accepted) {");
    Sb.AppendLine("    return {");
    Sb.AppendLine("      status: 'accepted',");
    Sb.AppendLine("      state: newStateJson.present,");
    Sb.AppendLine("      newVersion: toNumber(reply.dtor_newVersion),");
    Sb.AppendLine("      appliedAction: actionToJson(reply.dtor_applied),");
    Sb.AppendLine("      noChange: reply.dtor_noChange,");
    Sb.AppendLine("      appliedLog: newStateJson.appliedLog,");
    Sb.AppendLine("      auditLog: newStateJson.auditLog");
    Sb.AppendLine("    };");
    Sb.AppendLine("  } else {");
    Sb.AppendLine("    // Rejected");
    Sb.AppendLine("    return {");
    Sb.AppendLine("      status: 'rejected',");
    Sb.AppendLine("      reason: 'DomainInvalid',");
    Sb.AppendLine("      appliedAction: actionToJson(reply.dtor_rebased)");
    Sb.AppendLine("    };");
    Sb.AppendLine("  }");
    Sb.AppendLine("}");
  }

  void EmitDispatchInterfaces(DispatchConfig config)
  {
    Sb.AppendLine("export interface DispatchResult {");
    Sb.AppendLine("  status: 'accepted' | 'rejected';");
    Sb.AppendLine("  state?: any;");
    Sb.AppendLine("  appliedAction?: any;");
    Sb.AppendLine("  newVersion?: number;");
    Sb.AppendLine("  noChange?: boolean;");
    Sb.AppendLine("  appliedLog?: any[];");
    Sb.AppendLine("  auditLog?: any[];");
    Sb.AppendLine("  reason?: string;");
    Sb.AppendLine("}");
    Sb.AppendLine();
  }

  /// <summary>
  /// Emit ServerState conversion functions needed for dispatch.
  /// This should be called after datatype conversions.
  /// </summary>
  public void EmitServerStateConversions(string collaborationModule)
  {
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine("// ServerState Conversions (for verified Dispatch)");
    Sb.AppendLine("// ============================================================================");
    Sb.AppendLine();

    // serverStateFromJson
    Sb.AppendLine("// deno-lint-ignore no-explicit-any");
    Sb.AppendLine("const serverStateFromJson = (json: any): any => {");
    Sb.AppendLine("  const present = modelFromJson(json.present);");
    Sb.AppendLine();
    Sb.AppendLine("  // Convert appliedLog: Action[] -> Dafny seq<Action>");
    Sb.AppendLine("  const appliedActions = (json.appliedLog || []).map(actionFromJson);");
    Sb.AppendLine("  const appliedLog = _dafny.Seq.of(...appliedActions);");
    Sb.AppendLine();
    Sb.AppendLine("  // Convert auditLog: AuditRecord[] -> Dafny seq<RequestRecord>");
    Sb.AppendLine("  const auditRecords = (json.auditLog || []).map((rec: any) => {");
    Sb.AppendLine("    const outcome = rec.outcome.type === 'accepted'");
    Sb.AppendLine($"      ? {collaborationModule}.RequestOutcome.create_AuditAccepted(");
    Sb.AppendLine("          actionFromJson(rec.outcome.applied),");
    Sb.AppendLine("          rec.outcome.noChange || false");
    Sb.AppendLine("        )");
    Sb.AppendLine($"      : {collaborationModule}.RequestOutcome.create_AuditRejected(");
    Sb.AppendLine($"          {collaborationModule}.RejectReason.create_DomainInvalid(),");
    Sb.AppendLine("          actionFromJson(rec.outcome.applied || rec.rebased)");
    Sb.AppendLine("        );");
    Sb.AppendLine();
    Sb.AppendLine($"    return {collaborationModule}.RequestRecord.create_Req(");
    Sb.AppendLine("      new BigNumber(rec.baseVersion),");
    Sb.AppendLine("      actionFromJson(rec.orig),");
    Sb.AppendLine("      actionFromJson(rec.rebased),");
    Sb.AppendLine("      actionFromJson(rec.chosen),");
    Sb.AppendLine("      outcome");
    Sb.AppendLine("    );");
    Sb.AppendLine("  });");
    Sb.AppendLine("  const auditLog = _dafny.Seq.of(...auditRecords);");
    Sb.AppendLine();
    Sb.AppendLine($"  return {collaborationModule}.ServerState.create_ServerState(");
    Sb.AppendLine("    present,");
    Sb.AppendLine("    appliedLog,");
    Sb.AppendLine("    auditLog");
    Sb.AppendLine("  );");
    Sb.AppendLine("};");
    Sb.AppendLine();

    // serverStateToJson
    Sb.AppendLine("// deno-lint-ignore no-explicit-any");
    Sb.AppendLine("const serverStateToJson = (s: any): any => {");
    Sb.AppendLine("  const present = modelToJson(s.dtor_present);");
    Sb.AppendLine();
    Sb.AppendLine("  // Convert appliedLog: Dafny seq<Action> -> Action[]");
    Sb.AppendLine("  const appliedLog = seqToArray(s.dtor_appliedLog).map(actionToJson);");
    Sb.AppendLine();
    Sb.AppendLine("  // Convert auditLog: Dafny seq<RequestRecord> -> AuditRecord[]");
    Sb.AppendLine("  const auditLog = seqToArray(s.dtor_auditLog).map((rec: any) => {");
    Sb.AppendLine("    const outcome = rec.dtor_outcome;");
    Sb.AppendLine("    return {");
    Sb.AppendLine("      baseVersion: toNumber(rec.dtor_baseVersion),");
    Sb.AppendLine("      orig: actionToJson(rec.dtor_orig),");
    Sb.AppendLine("      rebased: actionToJson(rec.dtor_rebased),");
    Sb.AppendLine("      chosen: actionToJson(rec.dtor_chosen),");
    Sb.AppendLine("      outcome: outcome.is_AuditAccepted");
    Sb.AppendLine("        ? {");
    Sb.AppendLine("            type: 'accepted' as const,");
    Sb.AppendLine("            applied: actionToJson(outcome.dtor_applied),");
    Sb.AppendLine("            noChange: outcome.dtor_noChange");
    Sb.AppendLine("          }");
    Sb.AppendLine("        : {");
    Sb.AppendLine("            type: 'rejected' as const,");
    Sb.AppendLine("            reason: 'DomainInvalid',");
    Sb.AppendLine("            applied: actionToJson(outcome.dtor_rebased)");
    Sb.AppendLine("          }");
    Sb.AppendLine("    };");
    Sb.AppendLine("  });");
    Sb.AppendLine();
    Sb.AppendLine("  return { present, appliedLog, auditLog };");
    Sb.AppendLine("};");
    Sb.AppendLine();
  }
}
